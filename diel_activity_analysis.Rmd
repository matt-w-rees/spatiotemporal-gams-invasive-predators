---
title: "Diel activity GAMs"
author: "Matthew Rees"
date: "12/08/2021"
output:
  html_document:
    depth: 1
    number_sections: no
    theme: sandstone
    toc: yes
    toc_float: yes
    always_allow_html: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, warnings = FALSE, message = FALSE)
options(scipen = 999) 

library(dplyr)
library(mgcv)
library(ggplot2)
library(gganimate)
library(patchwork)
library(ggpubr)
library(viridis)
library(gratia)
library(chron)
library(sp)
library(sf)
library(reshape2)
library(lubridate)
library(stringr)
library(maptools)        
library(activity) 
library(lubridate)
library(pander)

# load function to change clock time to radial time for overlap package
source("r_scripts/function_clock_time_to_radian.R")

# Set the default theme for ggplot objects 
theme_set(theme_bw())
theme_update(panel.grid = element_blank())

```


```{r data prep, echo=FALSE}

# PREPARE DATA ------------------------------------------------------------
## load gam data - 23 rows for each hour of every deployment
records <- read.csv("derived_data/counts_hour.csv")

## EXCLUDE DATA
# drop zoi's data 
records <- filter(records, data_source != "zoi")
# exclude stations left out for less than 2 weeks 
records <- filter(records, survey_duration >= 10)
#hist(records$survey_duration / 23, breaks = 50)
#summary(records$survey_duration)

## MODIFY EVC GROUPS
# as we only had three "Riverine Grassy Woodlands or Forests" unique survey sites --> drop em
records <- filter(records, XGROUPNAME != "Riverine Grassy Woodlands or Forests")
# as we only had 20 "Rainforests" unique survey sites, all of which interspersed in "Wet Forests" in the Otways, reclassify as "Wet Forests". 
records$XGROUPNAME <- if_else(records$XGROUPNAME == "Rainforests", "Wet or Damp Forests", as.character(records$XGROUPNAME))
# abbreviate EVC group names for plotting
records$XGROUPNAME <- if_else(records$XGROUPNAME == "Wet or Damp Forests", "Wet Forests", records$XGROUPNAME)
records$XGROUPNAME <- if_else(records$XGROUPNAME == "Riparian Scrubs or Swampy Scrubs and Woodlands", "Swampy Scrubs", records$XGROUPNAME)
records$XGROUPNAME <- substr(records$XGROUPNAME, 1, nchar(records$XGROUPNAME) - 1)
#table(records$XGROUPNAME)

# add xy coordinates
records_sf <- st_as_sf(records, coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(crs = 32754)
records$x <- st_coordinates(records_sf)[,1]
records$y <- st_coordinates(records_sf)[,2]
#head(records)

# ADD FOX COUNTS PER CAMERA -----------------------------------------------
## Single fox count for each cam-trap (and do the same for cats for good measure)
records <- records %>%
  group_by(station_year)  %>%
  mutate(fox_count = sum(fox),
         cat_count = sum(cat))

# fox presence / absence
records$fox_pa <- if_else(records$fox_count > 0, "present", "absent")
records$cat_pa <- if_else(records$cat_count > 0, "present", "absent")
#xtabs(~records$fox_pa + records$cat_pa)

# adjust (positive only - we don't want negative counts) fox counts for survey effort 
records$fox_count_adj <- ifelse(records$fox_count > 0, records$fox_count/log(records$survey_duration), records$fox_count)

# and take the log (add 1 because you cant log 0)
records$fox_count_adj <- log(records$fox_count_adj + 1)
#hist(records$fox_count_adj)

## Add habitat type cov (for models 2/3)
records$habitat_type <- if_else(records$XGROUPNAME == "Wet Forest", "wet_otway", "dry_otway")
records$habitat_type <- if_else(records$region == "glenelg", "dry_glenelg", records$habitat_type)
records$habitat_type <- if_else(records$region == "glenelg", "dry_glenelg", records$habitat_type)
records$habitat_type <- if_else(is.na(records$habitat_type), "dry_otway", records$habitat_type)
#unique(records$habitat_type)

## Transform variable class  for GAMs
records <- transform(records,
                     hour = as.integer(hour),
                     cat = as.integer(cat), 
                     fox = as.integer(fox), 
                     foxbaits = as.integer(foxbaits), 
                     fox_pa = factor(fox_pa, ordered = FALSE), 
                     fox_count_adj = as.numeric(fox_count_adj), 
                     region = factor(region, ordered = FALSE), 
                     station = factor(station, ordered = FALSE), 
                     vegetation_group = factor(XGROUPNAME, ordered = FALSE), 
                     habitat_type = factor(habitat_type, ordered = FALSE), 
                     survey_duration = as.integer(survey_duration)
)
#summary(records)

# save modified dataframe
write.csv(records, "derived_data/counts_hour_cleaned.csv")

# split by region
records_g <- filter(records, region == "glenelg")
records_o <- filter(records, region == "otways")

```


## Changes spatial activity across the daily cycle

```{r space fox, cache = TRUE}

gam_fox_sp <- bam(fox ~ t2(x, y, hour, d = c(2, 1), bs = c("ds", "cc"), k = c(80, 8), m = c(1, 0.5), full = TRUE) +
                         s(foxbaits, bs = "tp", k = 4) + 
                         s(station, bs = "re") +  
                         offset(log(survey_duration)), 
                 data = records, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)
summary(gam_fox_sp)


gam_cat_sp <- bam(cat ~ t2(x, y, hour, d = c(2, 1), bs = c("ds", "cc"), k = c(80, 8), m = c(1, 0.5), full = TRUE) +
                         s(station, bs = "re") +  
                         offset(log(survey_duration)), 
                 data = records, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)
summary(gam_cat_sp)

```


### Spatial variation in the strength of diel patterns

```{r space plot creation, echo=FALSE}
#### FOX
### GLENELG
## STEP 1) Make buffer zone around cameras to restrict plotting - optional 
#take just the cams
records_g_cams <- distinct(records_g, station, .keep_all = TRUE)
# change it to sf class
records_g_cams <- st_as_sf(records_g_cams, coords = c("x", "y"), crs = 32754) 
# make a 4km buffer around each camera
glenelg_cams_buffer = st_buffer(records_g_cams, 4000)
# dissolve the buffer
glenelg_cams_buffer = st_union(glenelg_cams_buffer)
# convert back to dataframe
glenelg_buffer_df <- fortify(as_Spatial(glenelg_cams_buffer))%>%
  transmute(x = long, y = lat, order = order, group = group)
# split by each group (seperate polygon for each grid)
buffer_df1 <- glenelg_buffer_df[which(glenelg_buffer_df$group == "ID1.1"),]
buffer_df2 <- glenelg_buffer_df[which(glenelg_buffer_df$group == "ID1.2"),]
buffer_df3 <- glenelg_buffer_df[which(glenelg_buffer_df$group == "ID1.3"),]
buffer_df4 <- glenelg_buffer_df[which(glenelg_buffer_df$group == "ID1.4"),]

## STEP 2) MAKE A GRID TO PREDICT DATA INTO
data_g_plot = expand.grid(
  x = seq(min(glenelg_buffer_df$x), 
          max(glenelg_buffer_df$x),
          length=50),
  y = seq(min(glenelg_buffer_df$y),
          max(glenelg_buffer_df$y),
          length=50),
  survey_duration = 60,
  foxbaits = 0, 
  hour = c(0:23),
  station = "A001")

# subset to just locations within  of each camera 
data_g_plot1 = data_g_plot[with(data_g_plot, inSide(buffer_df1, x, y)),]
data_g_plot2 = data_g_plot[with(data_g_plot, inSide(buffer_df2, x, y)),]
data_g_plot3 = data_g_plot[with(data_g_plot, inSide(buffer_df3, x, y)),]
data_g_plot4 = data_g_plot[with(data_g_plot, inSide(buffer_df4, x, y)),]
data_g_plot <- rbind(data_g_plot1, data_g_plot2, data_g_plot3, data_g_plot4)

# predict model results into dataframe
data_g_plot <- cbind(data_g_plot, predict.gam(gam_fox_sp, newdata = data_g_plot, se.fit = TRUE, type = "link", exclude = c("s(station)", "s(survey_duration)")))
data_g_plot <- rename(data_g_plot, fox_predicted = fit,  fox_predicted_se = se.fit) # rename
# give each row / location a unique name to group by
data_g_plot$location_id <- paste0(data_g_plot$x, "_", data_g_plot$y)
# get difference in min max diel activity for each row
data_g_plot <- data_g_plot %>% 
  group_by(location_id) %>% 
  mutate(diel_diff = max(fox_predicted) - min(fox_predicted))

# fox plot: spatial activity per hour
g_fox_plot_hr <- ggplot(aes(x, y, fill = fox_predicted),
                     data = data_g_plot) +
  geom_tile()+
  scale_fill_viridis("log(activity)", option = "viridis", limits = c(-5.27, -1.13)) +
  geom_point(data = records_g, fill = NA, col = "white", size = 0.7, alpha = 0.1, shape = 3) +
  theme_bw(10) + 
  theme(axis.title = element_blank()) + 
    labs(title = 'Glenelg region; red fox; Hour: {frame_time}:00') +
  transition_time(hour) +
  ease_aes('linear')

# fox plot: spatial difference
g_fox_plot_diff <- ggplot(aes(x, y, fill = diel_diff),
                     data = data_g_plot) +
  geom_tile()+
  scale_fill_viridis("Relative diel pattern strength", option = "viridis", limits = c(0.5, 1.55), breaks=c(0.5, 1.03, 1.55),labels=c("low", "medium", "high")) +
  geom_point(data = records_g, fill = NA, col = "white", size = 0.7, alpha = 0.015, shape = 3) +
  theme_bw(10) + 
  ggtitle("a.  Glenelg region; red fox") +
  theme(axis.title = element_blank())


### OTWAYS
## STEP 1) Make buffer zone around cameras to restrict plotting - optional 
#take just the cams
records_o_cams <- distinct(records_o, station, .keep_all = TRUE)
# change it to sf class
records_o_cams <- st_as_sf(records_o_cams, coords = c("x", "y"), crs = 32754) 
# make a 4km buffer around each camera
otways_cams_buffer = st_buffer(records_o_cams, 6500)
# dissolve the buffer
otways_cams_buffer = st_union(otways_cams_buffer)
# convert back to dataframe
otways_buffer_df <- fortify(as_Spatial(otways_cams_buffer))%>%
  transmute(x = long, y = lat, order = order, group = group)

## STEP 2) MAKE A GRID TO PREDICT DATA INTO
data_o_plot = expand.grid(
  x = seq(min(otways_buffer_df$x), 
          max(otways_buffer_df$x),
          length=50),
  y = seq(min(otways_buffer_df$y),
          max(otways_buffer_df$y),
          length=50),
  station = "T053", 
  year = 2018,
  survey_duration = 60,
  hour = 0:23,
  foxbaits = 0)

# subset to just locations within buffer zone
data_o_plot = data_o_plot[with(data_o_plot, inSide(otways_buffer_df, x, y)),]
data_o_plot <- cbind(data_o_plot, predict.gam(gam_fox_sp, newdata = data_o_plot, se.fit = TRUE, type = "link", exclude = c("s(station)", "s(survey_duration)")))
data_o_plot <- rename(data_o_plot, fox_predicted = fit,  fox_predicted_se = se.fit) # rename
# give each row / location a unique name to group by
data_o_plot$location_id <- paste0(data_o_plot$x, "_", data_o_plot$y)
# get difference in min max diel activity for each row
data_o_plot <- data_o_plot %>% 
  group_by(location_id) %>% 
  mutate(diel_diff = max(fox_predicted) - min(fox_predicted))

# fox plot: spatial activity per hour
o_fox_plot_hr <- ggplot(aes(x, y, fill = fox_predicted),
                     data = data_o_plot) +
  geom_tile()+
  scale_fill_viridis("log(activity)", option = "viridis", limits = c(-5.27, -1.13)) +
  geom_point(data = records_o, fill = NA, col = "white", size = 0.7, alpha = 0.1, shape = 3) +
  theme_bw(10) + 
  theme(axis.title = element_blank()) + 
    labs(title = 'Otway Ranges; red fox; Hour: {frame_time}:00') +
  transition_time(hour) +
  ease_aes('linear')

# fox plot: spatial difference
o_fox_plot_diff <- ggplot(aes(x, y, fill = diel_diff),
                     data = data_o_plot) +
  geom_tile()+
  scale_fill_viridis("Relative diel pattern strength", option = "viridis", limits = c(0.5, 1.55), breaks=c(0.5, 1.03, 1.55),labels=c("low", "medium", "high")) +
  geom_point(data = records_o, fill = NA, col = "white", size = 0.7, alpha = 0.015, shape = 3) +
  theme_bw(10) + 
  ggtitle("c.  Otway Ranges; red fox") +
  theme(axis.title = element_blank())


#### CAT 
### GLENELG
# predict model results into dataframe
data_g_plot <- cbind(data_g_plot, predict.gam(gam_cat_sp, newdata = data_g_plot, se.fit = TRUE, type = "link", exclude = c("s(station)", "s(survey_duration)")))
data_g_plot <- rename(data_g_plot, cat_predicted = fit,  cat_predicted_se = se.fit) # rename
# give each row / location a unique name to group by
data_g_plot$location_id <- paste0(data_g_plot$x, "_", data_g_plot$y)
# get difference in min max diel activity for each row
data_g_plot <- data_g_plot %>% 
  group_by(location_id) %>% 
  mutate(diel_diff = max(cat_predicted) - min(cat_predicted))

# cat plot: spatial activity per hour
g_cat_plot_hr <- ggplot(aes(x, y, fill = cat_predicted),
                     data = data_g_plot) +
  geom_tile()+
  scale_fill_viridis("log(activity)", option = "viridis", limits = c(-5.27, -1.13)) +
  geom_point(data = records_g, fill = NA, col = "white", size = 0.7, alpha = 0.1, shape = 3) +
  theme_bw(10) + 
  theme(axis.title = element_blank()) + 
    labs(title = 'Glenelg region; feral cat; Hour: {frame_time}:00') +
  transition_time(hour) +
  ease_aes('linear')

# cat plot: spatial difference
g_cat_plot_diff <- ggplot(aes(x, y, fill = diel_diff),
                     data = data_g_plot) +
  geom_tile()+
  scale_fill_viridis("Relative diel pattern strength", option = "viridis", limits = c(0.5, 1.55), breaks=c(0.5, 1.03, 1.55),labels=c("low", "medium", "high")) +
  geom_point(data = records_g, fill = NA, col = "white", size = 0.7, alpha = 0.015, shape = 3) +
  theme_bw(10) + 
  ggtitle("b.  Glenelg region; feral cat") +
   theme(axis.title = element_blank())

### OTWAYS
# predict model results into dataframe
data_o_plot <- cbind(data_o_plot, predict.gam(gam_cat_sp, newdata = data_o_plot, se.fit = TRUE, type = "link", exclude = c("s(station)", "s(survey_duration)")))
data_o_plot <- rename(data_o_plot, cat_predicted = fit,  cat_predicted_se = se.fit) # rename
# give each row / location a unique name to group by
data_o_plot$location_id <- paste0(data_o_plot$x, "_", data_o_plot$y)
# get difference in min max diel activity for each row
data_o_plot <- data_o_plot %>% 
  group_by(location_id) %>% 
  mutate(diel_diff = max(cat_predicted) - min(cat_predicted))

# cat plot: spatial activity per hour
o_cat_plot_hr <- ggplot(aes(x, y, fill = cat_predicted),
                     data = data_o_plot) +
  geom_tile()+
  scale_fill_viridis("log(activity)", option = "viridis", limits = c(-5.27, -1.13)) +
  geom_point(data = records_o, fill = NA, col = "white", size = 0.7, alpha = 0.1, shape = 3) +
  theme_bw(10) + 
  theme(axis.title = element_blank()) + 
    labs(title = 'Otway Ranges; feral cat; Hour: {frame_time}:00') +
  transition_time(hour) +
  ease_aes('linear')

# cat plot: spatial difference
o_cat_plot_diff <- ggplot(aes(x, y, fill = diel_diff),
                     data = data_o_plot) +
  geom_tile()+
  scale_fill_viridis("Relative diel pattern strength", option = "viridis", limits = c(0.5, 1.55), breaks=c(0.5, 1.03, 1.55),labels=c("low", "medium", "high")) +
  geom_point(data = records_o, fill = NA, col = "white", size = 0.7, alpha = 0.015, shape = 3) +
  theme_bw(10) + 
  ggtitle("d.  Otway Ranges; feral cat") +
  theme(axis.title = element_blank())

```

```{r x, echo=FALSE, out.width = '80%'}
g_fox_plot_hr 
```

```{r , echo=FALSE, out.width = '80%'}
g_cat_plot_hr 
```

```{r , echo=FALSE, out.width = '80%'}
o_fox_plot_hr 
```

```{r , echo=FALSE, out.width = '80%'}
o_cat_plot_hr
```


```{r space plot diff, echo=FALSE}
# save 
png("figs/diel_strength_600dpi.png", width = 10, height = 9, res = 600, units = "in")
ggarrange(g_fox_plot_diff, g_cat_plot_diff, o_fox_plot_diff, o_cat_plot_diff, ncol=2, nrow=2, common.legend = TRUE, legend="bottom", heights=c(4.25, 3.25))
dev.off()

```


## Spatiotemporal activity across vegetation types

```{r , cache=TRUE}
gam_fox_veg <- bam(fox ~ s(hour, bs = "cc", k = 8) +   
                         s(hour, vegetation_group, bs = "fs", xt = list(bs = "cc"), k = 8) + 
                         s(foxbaits, region, bs = "fs", xt = list(bs = "tp"), k = 4) + 
                         s(region, bs = "re") +  
                         s(station, bs = "re") +  
                         offset(log(survey_duration)), 
                   data = records, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)
      
summary(gam_fox_veg)


gam_cat_veg <- bam(cat ~ s(hour, bs = "cc", k = 8) +   
                         s(hour, vegetation_group, bs = "fs", xt = list(bs = "cc"), k = 8) +  
                         s(region, bs = "re") +  
                         s(station, bs = "re") +  
                         offset(log(survey_duration)), 
                   data = records, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)
                 
summary(gam_cat_veg)
```


```{r , echo=FALSE}
# PLOT MODEL 1 ------------------------------------------------------------------
# get average sunrise / sunset times for plots
#mean(times(records$sunrise))
#mean(times(records$sunset))

# function to run and plot GAMs for each species
gam_plot <- function(gam_model, data){
  ## Plot global smooth (using the gratia package)
  plot_global <- draw(evaluate_smooth(gam_model, overall_uncertainty = TRUE, "s(hour)"), xlab = "Hour",  title = "", subtitle = "i.   Average") + 
    geom_vline(xintercept = c(6.16,18.34), colour = "black", size = 0.6, linetype="dotted") 
  ## Plot the difference smooths using the gratia package
  plot_difference <- draw(evaluate_smooth(gam_model, "s(hour,vegetation_group)"), xlab = "Hour",  title = "", subtitle = "ii.   Vegetation-specific deviations from the average") + 
    geom_vline(xintercept = c(6.16,18.34), colour = "black", size = 0.6, linetype="dotted") 
  ## Plot the actual hourly activity for each vegetation type   
  # make a new dataframe to predict into
  df <- expand.grid(hour = 0:23,
                    vegetation_group = levels(data$vegetation_group),
                    foxbaits = 0, 
                    region = c("glenelg", "otways"),
                    survey_duration = mean(data$survey_duration))
  # get smooths to exlude
  x = sapply(gam_model$smooth, "[[",  "label")
  # predict model estimates (and uncertainty) into this dataframe, excluding the impact of variables other than hour:
  df <- cbind(df, predict.gam(gam_model, newdata = df, se.fit = TRUE, type = "link", newdata.guaranteed = TRUE, exclude = c(x[3:7], "s(survey_duration)")))
  plot_veg <- ggplot(data=df, aes(x=hour, y=fit, group=vegetation_group)) +
    # ylim(-13, -2) +
    geom_line(aes(y=fit, x=hour), lwd = 0.7) +
    facet_wrap(~vegetation_group, nrow =1) +
    geom_ribbon(aes(ymin=(fit-2*se.fit), ymax=(fit+2*se.fit)), alpha=0.2) +
    geom_vline(xintercept = c(6.16,18.34), colour = "black", size = 0.6, linetype="dotted") + 
    labs(subtitle = "iii.   Predicted activity", x = "Hour", y = "log(count)") 
  ## Assemble plots
  patch <- (plot_global | plot_difference) / plot_veg 
  patch
}

# save
png("figs/fox_veg.png", width = 9, height = 5, res = 600, units = "in")
gam_plot(gam_fox_veg, records) + plot_annotation(title = "a.   Fox")
dev.off()

png("figs/cat_veg.png", width = 9, height = 5, res = 600, units = "in")
gam_plot(gam_cat_veg, records) + plot_annotation(title = "b.   Feral cat")
dev.off()

# to combine figures, type in the terminal (using imagemagick): 
# convert figs/fox_veg.png figs/cat_veg.png  -append figs/predator_veg.png

```


## Spatiotemporal activity in response to apex predator threat

```{r , cache = TRUE}
gam_cat_fox <- bam(cat ~ habitat_type + t2(hour, fox_count_adj, by = habitat_type, bs = c("cc", "ts"), k = c(8, 5), full = TRUE) +  
                    s(longitude, latitude, bs = "ds",  m = c(1, 0.5), k = 200) +
                    s(station, bs = "re") +  
                    offset(log(survey_duration)), 
                  data = records, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)

summary(gam_cat_fox)
```

```{r , echo=FALSE}

# PLOT MODEL 2B ------------------------------------------------------------------
df = expand.grid(hour = 0:23,
                 habitat_type = levels(records$habitat_type),
                 longitude = mean(records$longitude),
                 latitude = mean(records$latitude),
                 fox_count_adj = seq(min(records$fox_count_adj), max(records$fox_count_adj), length=150),
                 station = "T052",
                 survey_duration = mean(records$survey_duration))
# predict model results into dataframe
x = sapply(gam_cat_fox$smooth, "[[",  "label")
df_int <- cbind(df, predict(gam_cat_fox, newdata = df, se.fit = TRUE, type = "link", exclude = c(x[4:5], "s(survey_duration)")))
# plot
plot_range <- ggplot(aes(hour, fox_count_adj, fill = fit), data = df_int) +
  geom_tile() +
  facet_wrap(~habitat_type, nrow =1) +
  scale_fill_viridis("log(count)", option = "viridis") + 
  ggtitle("", subtitle = "Feral cat activity") +
  geom_vline(xintercept = c(6.16,18.34), colour = "grey75", size = 1) + 
  ylab("log(adjusted fox count)") + 
  xlab("Hour") 

# plot standard error 
plot_range_se <- ggplot(aes(hour, fox_count_adj, fill = se.fit), data = df_int) +
  geom_tile() +
  facet_wrap(~habitat_type, nrow =1) +
  scale_fill_viridis("Standard error", option = "viridis") + 
  ggtitle("", subtitle = "Uncertainty") +
  geom_vline(xintercept = c(6.16,18.34), colour = "grey75", size = 1) + 
  ylab("log(adjusted fox count)") + 
  xlab("Hour") 

#  save
png("figs/cat_fox_count.png", width = 9, height = 6.5, res = 600, units = "in")
plot_range / plot_range_se + plot_annotation(tag_levels = "a")
dev.off()

```

## Individual heterogeneity in diel activity

```{r , echo=FALSE}
## LOAD PREPARE INDIVIDUAL CAT DATA FROM MATTS PHD

# load cat records
records <- read.csv("raw_data/cat_id_detections.csv")
records$X <- NULL

# load camdata - but just matts deployments
camdata <- read.csv("raw_data/camdata.csv")
camdata <- filter(camdata, data_source == "matt")
camdata$X <- NULL
camdata$X.1 <- NULL


# ADD SOLAR TIMES ---------------------------------------------------------
# take a matrix of the coordinates
coords <- matrix(c(records$longitude, records$latitude), nrow = length(records$latitude))
# add a coordinate reference system (can't be UTM)
coords <- sp::SpatialPoints(coords, proj4string=sp::CRS("+proj=longlat +datum=WGS84")) 

# specify detection time as a date class, as well as timezone (use Brisbane because it doesn't have daylight savings)
records$date_time <- ymd_hms(records$date_time, tz = "Australia/Brisbane")

# calculate the time of sunrise given the location and timing of each species detection 
sunriset_df <- as.data.frame(sunriset(coords, records$date_time, direction = "sunrise", POSIXct.out=TRUE))
# convert to radian time 
sunrise_radian <- ClocktimeToTimeRad(sunriset_df$time) 
# calculate the time of sunset given the location and timing of each species detection 
sunsett_df <- as.data.frame(sunriset(coords, records$date_time, direction = "sunset", POSIXct.out=TRUE))
# convert to radian 
sunset_radian <- ClocktimeToTimeRad(sunsett_df$time) 

# save these as a separate matrix for the transtime function below 
anchors <- matrix(c(sunrise_radian, sunset_radian), nrow = length(sunset_radian))

# we also need to convert the detection time to radian time
det_radian <- ClocktimeToTimeRad(records$date_time)

# we can now calculate the average anchored time (time relative to both sunrise and sunset) for every detection
det_anchored <- transtime(det_radian, anchors)

# add to dataframe
records$aa_radian <- det_anchored
# as well as in clock time (new cols)
records$aa_clock <- records$aa_radian * 3.81971


# REMOVE REPEAT DETECTIONS ------------------------------------------------

## remove records of the same species at a particular cam-trap within 30 minutes
time_to_independence <- 1800 # number of seconds in 30 minutes

# get time (in seconds) since last visit
records <- records %>%
  group_by(station_year, individual) %>%
  arrange(date_time) %>%
  mutate(seconds_diff = date_time - lag(date_time))

# change NA's to a value greater than the time to independence so they get kept when we filter out 
records$seconds_diff[is.na(records$seconds_diff)] <- time_to_independence + 1

# filter out records less than 60 minutes
records <- filter(records, seconds_diff > time_to_independence)

# remove seconds_diff col
records$seconds_diff <- NULL


# SPLIT COMBINED CATS ---------------------------------------------------------
# duplicate row and split individual name
records_double1 <- filter(records, individual == "otway_swirl_venus_&_otway_swirl_peter" | individual == "annya_swirl_ben_&_annya_swirl_motley")
records_double2 <- filter(records, individual == "otway_swirl_venus_&_otway_swirl_peter" | individual == "annya_swirl_ben_&_annya_swirl_motley")
records_double1$individual <- str_split_fixed(records_double1$individual, "_&_", 2)[,1]
records_double2$individual <- str_split_fixed(records_double2$individual, "_&_", 2)[,2]
records_double1$coat_type <- str_split_fixed(records_double1$coat_type, "_&_", 2)[,1]
records_double2$coat_type <- if_else(records_double2$coat_type == "tortoise_&_tabby", "tabby", as.character(records_double2$coat_type))
records_double <- rbind(records_double1, records_double2)

# remove these rows from records
records <- filter(records, is.na(individual) | individual != "otway_swirl_venus_&_otway_swirl_peter")
records <- filter(records, is.na(individual) | individual != "annya_swirl_ben_&_annya_swirl_motley")

# now add the new ones in 
records <- rbind(records, records_double)


# RESHAPE BY HOUR ---------------------------------------------------------
# DATAFRAME 1:  HOUR ----------------------------------------------------
# need to do this for summing
records$occ <- 1

# make solar hour an integer, of character class
records$hour <- as.integer(records$aa_clock)
records$species <- "cat"

# split by region
records_g <- filter(records, region == "glenelg")
records_o <- filter(records, region == "otways")
# do same for camdata
camdata_g <- filter(camdata, region == "glenelg")
camdata_o <- filter(camdata, region == "otways")

# melt the dataframe
gam_data_g <- melt(records_g, id.var = colnames(records_g), measure.var = "occ")
gam_data_o <- melt(records_o, id.var = colnames(records_o), measure.var = "occ")

# cast to derive count per year per station_year long format
gam_data_g = dcast(gam_data_g,  individual + station_year + hour ~ species, fill = 0, fun = sum)
gam_data_o = dcast(gam_data_o,  individual + station_year + hour ~ species, fill = 0, fun = sum)

# make a table with all unique combinations - (use camdata so we don't just take the sites with detections)
df_g <- expand.grid(station_year = unique(camdata_g$station_year), individual = unique(records_g$individual), hour = 0:23)
df_o <- expand.grid(station_year = unique(camdata_o$station_year), individual = unique(records_o$individual), hour = 0:23)

# merge into gam_data so every hour for every station is provided (even with no predator detections) - fills missing values with NA
gam_data_g <- left_join(df_g, gam_data_g)
gam_data_o <- left_join(df_o, gam_data_o)

# change NA's to 0's
gam_data_g$cat <- ifelse(is.na(gam_data_g$cat), 0, gam_data_g$cat)
gam_data_o$cat <- ifelse(is.na(gam_data_o$cat), 0, gam_data_o$cat)

# sort by station, hour
gam_data_g <- arrange(gam_data_g, individual, station_year, hour)
gam_data_o <- arrange(gam_data_o, individual, station_year, hour)

## merge in site covariates
gam_data_g <- left_join(gam_data_g, camdata_g, by = "station_year")
gam_data_o <- left_join(gam_data_o, camdata_o, by = "station_year")

# ADD SUNSET SUNRISE TIMES FOR STATIONS ------------------------------------------
## glenelg 
# make date class
#gam_data_g$date_start <- ymd(gam_data_g$date_start, tz = "Australia/Brisbane")
#gam_data_g$date_end <- ymd(gam_data_g$date_end, tz = "Australia/Brisbane")
## take a matrix of the coordinates
#coords <- matrix(c(gam_data_g$longitude, gam_data_g$latitude), nrow = length(gam_data_g$latitude))
## add a coordinate reference system (can't be UTM)
#coords <- sp::SpatialPoints(coords, proj4string=sp::CRS("+proj=longlat +datum=WGS84")) 
## calculate the time of sunrise given the location and timing of each species detection - midway point for survey
#sunriset_df <- as.data.frame(sunriset(coords, gam_data_g$date_start + days(as.integer(gam_data_g$survey_duration / 2)), direction = #"sunrise", POSIXct.out=TRUE))
## calculate the time of sunset given the location and timing of each species detection - midway point for survey
#sunsett_df <- as.data.frame(sunriset(coords, gam_data_g$date_start + days(as.integer(gam_data_g$survey_duration / 2)), direction = #"sunset", POSIXct.out=TRUE))
## load hms r package here so it does't conflict with lubridate^
#library(hms)
## add time only to dataframe using hms package
#gam_data_g$sunrise <- hms::as_hms(lubridate::ymd_hms(sunriset_df$time, tz = "Australia/Brisbane"))
#gam_data_g$sunset <- hms::as_hms(lubridate::ymd_hms(sunsett_df$time, tz = "Australia/Brisbane"))
#
## otways
## make date class
#gam_data_o$date_start <- ymd(gam_data_o$date_start, tz = "Australia/Brisbane")
#gam_data_o$date_end <- ymd(gam_data_o$date_end, tz = "Australia/Brisbane")
## take a matrix of the coordinates
#coords <- matrix(c(gam_data_o$longitude, gam_data_o$latitude), nrow = length(gam_data_o$latitude))
## add a coordinate reference system (can't be UTM)
#coords <- sp::SpatialPoints(coords, proj4string=sp::CRS("+proj=longlat +datum=WGS84")) 
## calculate the time of sunrise given the location and timing of each species detection - midway point for survey
#sunriset_df <- as.data.frame(sunriset(coords, gam_data_o$date_start + days(as.integer(gam_data_o$survey_duration / 2)), direction = #"sunrise", POSIXct.out=TRUE))
## calculate the time of sunset given the location and timing of each species detection - midway point for survey
#sunsett_df <- as.data.frame(sunriset(coords, gam_data_o$date_start + days(as.integer(gam_data_o$survey_duration / 2)), direction = #"sunset", POSIXct.out=TRUE))
## add time only to dataframe using hms package
#gam_data_o$sunrise <- hms::as_hms(lubridate::ymd_hms(sunriset_df$time, tz = "Australia/Brisbane"))
#gam_data_o$sunset <- hms::as_hms(lubridate::ymd_hms(sunsett_df$time, tz = "Australia/Brisbane"))
#
## get averages (use in plot)
#library(chron)
#mean(times(gam_data_g$sunrise))
#mean(times(gam_data_g$sunset))
#mean(times(gam_data_o$sunrise))
#mean(times(gam_data_o$sunset))


## Transform variable class  for GAMs
gam_data_o <- transform(gam_data_o,
                       hour = as.integer(hour),
                       individual = factor(individual, ordered = FALSE), 
                       station = factor(station, ordered = FALSE), 
                       survey_duration = as.integer(survey_duration)
)

gam_data_g <- transform(gam_data_g,
                        hour = as.integer(hour),
                        individual = factor(individual, ordered = FALSE), 
                        station = factor(station, ordered = FALSE), 
                        survey_duration = as.integer(survey_duration)
)

#levels(gam_data_g$individual)
#levels(gam_data_o$individual)


```



```{r , cache=TRUE}

gam_cat_ind_o <- bam(cat ~ s(hour, bs = "cc", k = 8) +   
                           s(hour, individual, bs = "fs", xt = list(bs = "cc"), k = 8) +  
                           s(longitude, latitude, bs = "ds",  m = c(1, 0.5), k = 150) +
                           s(station, bs = "re") +  
                           offset(log(survey_duration)), 
                     data = gam_data_o, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)

summary(gam_cat_ind_o)


gam_cat_ind_g <- bam(cat ~ s(hour, bs = "cc", k = 8) +   
                           s(hour, individual, bs = "fs", xt = list(bs = "cc"), k = 8) +  
                           s(longitude, latitude, bs = "ds",  m = c(1, 0.5), k = 150) +
                           offset(log(survey_duration)), 
                     data = gam_data_g, family = nb, knots = list(hour = c(0, 23)), nthreads = 3, discrete = TRUE)

summary(gam_cat_ind_g)
```


```{r , echo=FALSE}
# plot individuals
## 1st get top 7 cats with most detections
top7_g <- slice_max(as.data.frame(table(records_g$individual)), order_by = Freq, n = 7, with_ties = FALSE)
top7_o <- slice_max(as.data.frame(table(records_o$individual)), order_by = Freq, n = 7, with_ties = FALSE)

## glenelg
## Plot global smooth (using the gratia package)
plot_global <- draw(evaluate_smooth(gam_cat_ind_g, overall_uncertainty = TRUE, "s(hour)"), xlab = "Hour",  title = "", subtitle = "i.   Average") + 
  geom_vline(xintercept = c(7.01,18.12), colour = "black", size = 0.6, linetype="dotted") 
## Plot the difference smooths using the gratia package
plot_difference <- draw(evaluate_smooth(gam_cat_ind_g, "s(hour,individual)"), xlab = "Hour",  title = "", subtitle = "ii.   Individual deviations from the average") + 
  geom_vline(xintercept = c(7.01,18.12), colour = "black", size = 0.6, linetype="dotted") 
## Plot the actual hourly activity for each vegetation type   
# make a new dataframe to predict into
df <- expand.grid(hour = 0:23,
                  individual = unique(top7_g$Var1),
                  survey_duration = mean(gam_data_g$survey_duration))
# get smooths to exlude
x = sapply(gam_cat_ind_g$smooth, "[[",  "label")
# predict model estimates (and uncertainty) into this dataframe, excluding the impact of variables other than hour:
df <- cbind(df, predict.gam(gam_cat_ind_g, newdata = df, se.fit = TRUE, type = "link", newdata.guaranteed = TRUE, exclude = c(x[3:6], "s(survey_duration)")))
# shorten cat names
df$individual <- as.character(df$individual)
df$individual <- recode(df$individual, annya_swirl_lola = "faith", c_tabby_quasimodo = "brisket", m_swirl_socksy = "boots", annya_swirl_ben = "dolly", annya_swirl_motley = "motley", hotspur_tabby_1 = "sprout", m_tabby_murray = "murray")
# plot top 7 individuals
plot_ind <- ggplot(data=df, aes(x=hour, y=fit, group=individual)) +
  geom_line(aes(y=fit, x=hour), lwd = 0.7) +
  facet_wrap(~individual, nrow =1) +
  geom_ribbon(aes(ymin=(fit-2*se.fit), ymax=(fit+2*se.fit)), alpha=0.2) +
  geom_vline(xintercept = c(7.01,18.12), colour = "black", size = 0.6, linetype="dotted") + 
  labs(subtitle = "iii.   Predicted activity", x = "Hour", y = "log(count)") 

# plot / save
png("figs/cat_ind_g.png", width = 9, height = 5, res = 600, units = "in")
(plot_global | plot_difference) / plot_ind  + plot_annotation(title = "a.   Glenelg region")
dev.off()


## otways
## Plot global smooth (using the gratia package)
plot_global <- draw(evaluate_smooth(gam_cat_ind_o, overall_uncertainty = TRUE, "s(hour)"), xlab = "Hour",  title = "", subtitle = "i.   Average") + 
  geom_vline(xintercept = c(7.27,17.38), colour = "black", size = 0.6, linetype="dotted") 
## Plot the difference smooths using the gratia package
plot_difference <- draw(evaluate_smooth(gam_cat_ind_o, "s(hour,individual)"), xlab = "Hour",  title = "", subtitle = "ii.   Individual deviations from the average") + 
  geom_vline(xintercept = c(7.27,17.38), colour = "black", size = 0.6, linetype="dotted") 
## Plot the actual hourly activity for each vegetation type   
# make a new dataframe to predict into
df <- expand.grid(hour = 0:23,
                  individual = unique(top7_o$Var1),
                  survey_duration = mean(gam_data_o$survey_duration))
# get smooths to exlude
x = sapply(gam_cat_ind_o$smooth, "[[",  "label")
# predict model estimates (and uncertainty) into this dataframe, excluding the impact of variables other than hour:
df <- cbind(df, predict.gam(gam_cat_ind_o, newdata = df, se.fit = TRUE, type = "link", newdata.guaranteed = TRUE, exclude = c(x[3:6], "s(survey_duration)")))
# shorten cat names
df$individual <- as.character(df$individual)
df$individual <- recode(df$individual, otway_tabby_javier = "pav", otway_swirl_skip = "skip", otway_tabby_crass = "crass", otway_tabby_meg = "pauline", otway_swirl_bluey = "bluey", otway_swirl_chowder = "chowder", otway_tabby_catsup = "percy")
# plot top 7 individuals
plot_ind <- ggplot(data=df, aes(x=hour, y=fit, group=individual)) +
  geom_line(aes(y=fit, x=hour), lwd = 0.7) +
  facet_wrap(~individual, nrow =1) +
  geom_ribbon(aes(ymin=(fit-2*se.fit), ymax=(fit+2*se.fit)), alpha=0.2) +
  geom_vline(xintercept = c(7.27,17.38), colour = "black", size = 0.6, linetype="dotted") + 
  labs(subtitle = "iii.   Predicted activity", x = "Hour", y = "log(count)") 

# plot / save
png("figs/cat_ind_o.png", width = 9, height = 5, res = 600, units = "in")
(plot_global | plot_difference) / plot_ind  + plot_annotation(title = "b.   Western Otway Ranges")
dev.off()

# to combine figures, type in the terminal (using imagemagick): 
# convert figs/cat_ind_g.png figs/cat_ind_o.png  -append figs/cat_ind.png

```



## Session information

```{r , echo = FALSE}

sessionInfo() %>% pander()

```

